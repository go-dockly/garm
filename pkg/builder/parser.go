package builder

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strings"
)

// SSAPhase represents a single phase in the SSA compilation process
type SSAPhase struct {
	Name string
	Code []string
}

// SSAParseResult contains the parsed SSA information
type SSAParseResult struct {
	FunctionName string
	Phases       []SSAPhase
}

// ParseSSAOutput reads and parses the SSA output file generated by GOSSAFUNC
func ParseSSAOutput(filepath string) (*SSAParseResult, error) {
	file, err := os.Open(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to open SSA output file: %v", err)
	}
	defer file.Close()

	result := &SSAParseResult{
		Phases: make([]SSAPhase, 0),
	}

	scanner := bufio.NewScanner(file)

	// Regular expressions for parsing
	phaseHeaderRegex := regexp.MustCompile(`^--- (.+) ---$`)
	funcNameRegex := regexp.MustCompile(`^# name: (.+)$`)

	var currentPhase *SSAPhase

	for scanner.Scan() {
		line := scanner.Text()

		// Check for function name
		if matches := funcNameRegex.FindStringSubmatch(line); matches != nil {
			result.FunctionName = matches[1]
			continue
		}

		// Check for phase header
		if matches := phaseHeaderRegex.FindStringSubmatch(line); matches != nil {
			// Save previous phase if it exists
			if currentPhase != nil && len(currentPhase.Code) > 0 {
				result.Phases = append(result.Phases, *currentPhase)
			}

			// Start new phase
			currentPhase = &SSAPhase{
				Name: matches[1],
				Code: make([]string, 0),
			}
			continue
		}

		// Add line to current phase if we're in one
		if currentPhase != nil {
			// Skip empty lines at the start of a phase
			if len(currentPhase.Code) == 0 && strings.TrimSpace(line) == "" {
				continue
			}
			currentPhase.Code = append(currentPhase.Code, line)
		}
	}

	// Add the last phase if it exists
	if currentPhase != nil && len(currentPhase.Code) > 0 {
		result.Phases = append(result.Phases, *currentPhase)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading SSA output file: %v", err)
	}

	return result, nil
}

// ParseSSAInstruction parses a single SSA instruction line
func ParseSSAInstruction(line string) map[string]string {
	result := make(map[string]string)

	// Remove leading whitespace and get the instruction number if present
	line = strings.TrimLeft(line, " \t")
	if match := regexp.MustCompile(`^v(\d+) = `).FindStringSubmatch(line); match != nil {
		result["value"] = match[1]
		line = line[len(match[0]):]
	}

	// Extract the operation
	if match := regexp.MustCompile(`^([A-Za-z0-9.]+)`).FindStringSubmatch(line); match != nil {
		result["operation"] = match[1]
		line = line[len(match[0]):]
	}

	// Extract arguments
	line = strings.TrimSpace(line)
	if len(line) > 0 {
		result["args"] = line
	}

	return result
}

// GetPhase returns a specific phase by name
func (r *SSAParseResult) GetPhase(name string) *SSAPhase {
	for i := range r.Phases {
		if r.Phases[i].Name == name {
			return &r.Phases[i]
		}
	}
	return nil
}
